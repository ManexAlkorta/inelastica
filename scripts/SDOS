#! /usr/bin/env python
"""
Calculate dos from the surface Green's function from a electrode calculation

NOTE! The DOS is a sum over the atoms of the unitcell.
NOTE! The outfile contains the DOS divided into s,p,d,f shells.
      This decomposition is not perfect since polarized basis orbitals
      will end up in L+1 part, i.e., 6s polarized orbital = 6p
"""
import sys, profile, glob
#sys.path+=['../..']

import Inelastica.pyTBT as pyTBT
import numpy as N
import numpy.linalg as LA
import Inelastica.SiestaIO as SIO
from optparse import OptionParser
import xml.dom.minidom as xml
import gzip

#####################################################
# Mathematical help functions
def mm(* args):
    # Matrix multiplication with arbitrary number of arguments
    tmp=N.dot(args[0],args[1])
    for ii in range(len(args)-2):
        tmp=N.dot(tmp,args[ii+2])
    return tmp

def dag(x):
    return N.transpose(N.conjugate(x))



#####################################################
# Read options
def readOptions():
    usage = "usage: %prog [options]"
    description = """
Calculate SDOS of whole or part of system divided into s-, p-, d-, f- shells.
The DOS is summed over the "device" atoms for each angular momenta L.

For help use --help!
"""
    parser = OptionParser(usage,description=description)
    # k-points
    parser.add_option("-x", "--Nkx", dest="Nkx",
                      help="Number of k-points in a1 direction [%default]", 
                      type='int', default=1)
    parser.add_option("-y", "--Nky", dest="Nky",
                      help="Number of k-points in a2 direction [%default]", 
                      type='int', default=1)

    # Spin channel
    parser.add_option("-s", "--iSpin", dest="iSpin",
                      help="Spin type (1-up, 2-down) [%default]", 
                      type='int', default=1)

    # Left / Right?
    parser.add_option("-r", "--Right", dest='LR', default=False,
                      action='store_true',
                      help="Left (false) or Right (true) SDOS [%default]")
    parser.add_option("-b", "--both", dest='both', default=False,
                      action='store_true',
                      help="Left+right SDOS [%default]")

    (general, args) = parser.parse_args()
    print description
    return general, parser

#####################################################
# Main program
def main():    
    # Read arguments
    general, parser = readOptions()

    # Setup pyTBT part
    elecL, elecR, myGF, pyTBTdevSt, pyTBTdevEnd, general.Elist, \
           general.eta, general.outFile = pyTBT.main(pyTBT=False, fn='RUN.fdf')

    general.devSt = pyTBTdevSt
    general.devEnd = pyTBTdevEnd
    
    print "##############################################################"
    print "# Options:"
    if general.both:
        print "Calculation of DOS from BOTH electrodes"
    elif general.LR:
        print "Calculation of DOS from RIGHT electrode"
    else:
        print "Calculation of DOS from LEFT electrode"
    print "Num k-points   : Nka1 %i : Nka2 %i"%(general.Nkx,general.Nky)
    print "Broadening eta : %f"%(general.eta)
    print "Device region  : [%i,%i]"%(general.devSt,
                                    general.devEnd)
    print "Spin channel   : %i"%(general.iSpin)
    print "##############################################################"
    print
    
    # Read basis
    basis=SIO.BuildBasis(general.outFile+'.XV',1,myGF.HS.nua,myGF.HS.lasto)
    print

    """
    nou = number of orbitals in unitcell.
    nouL/R = number of orbitals where self-energies live
    Full space   : myGF.nou0, myGF.nouL0, nouR0  [orbital number]
    pyTBT folded : myGF.nou, myGF.nouL, nouR     [orbital number]
                 : pyTBTdevSt, pyTBTdevEnd       [atom number]
    SDOS devide  : general.devSt, general.devEnd [atom number]
    
    Connection from atom number to orbital number in full device space is
    given by myGF.HS.lasto (which uses Siesta numbering [1,nou])

    basis is defined on the full space.
    """

    # First, last orbital in full space and pyTBT folded space.
    devOrbSt = myGF.HS.lasto[general.devSt-1]
    pyTBTdevOrbSt = devOrbSt-myGF.HS.lasto[pyTBTdevSt-1]
    devOrbEnd = myGF.HS.lasto[general.devEnd]-1
    pyTBTdevOrbEnd = devOrbEnd-myGF.HS.lasto[pyTBTdevSt-1]
    
    DOS=N.zeros((len(general.Elist),myGF.nuo),N.float)

    kpt=N.zeros((2),N.float)
    for iee, ee in enumerate(general.Elist):
        # Calculate spectral function A1/A2 average over k 
        Aav = N.zeros((myGF.nuo,myGF.nuo),N.complex)
        for ikx in range(general.Nkx):
            for iky in range(general.Nky):
                kpt[0], kpt[1] = float(ikx)/general.Nkx, float(iky)/general.Nky
                myGF.calcGF(ee+general.eta*1.0j, kpoint=kpt,
                            ispin=general.iSpin-1)
                GamL, GamR, Gr = myGF.GamL, myGF.GamR, myGF.Gr
                nuo, nuoL, nuoR = myGF.nuo, myGF.nuoL, myGF.nuoR

                if general.LR or general.both:
                    # Right : A2
                    A = mm(Gr[:,nuo-nuoR:nuo],GamR,dag(Gr)[nuo-nuoR:nuo,:])
                    
                if general.both:
                    # Left : A1
                    A += mm(Gr[:,0:nuoL],GamL,dag(Gr)[0:nuoL,:])
                elif not general.LR:
                    A = mm(Gr[:,0:nuoL],GamL,dag(Gr)[0:nuoL,:])
                Aav += mm(myGF.S,A)

        # DOS
        Aav = Aav.real/(general.Nkx*general.Nky*2*N.pi)
        DOS[iee,:] += N.diag(Aav)

        print ee," ",N.sum(DOS[iee,:])

    doc = xml.Document()
    pdos = doc.createElement('pdos')
    doc.appendChild(pdos)
    xmladd(doc,pdos,'nspin','%i'%general.iSpin)
    xmladd(doc,pdos,'norbitals','%i'%(nuo))
    xmladd(doc,pdos,'energy_values',myprint(general.Elist))
    for ii in range(nuo):
        orb = doc.createElement('orbital')
        pdos.appendChild(orb)
        io = myGF.nuoL+ii
        orb.setAttribute('index','%i'%io)
        orb.setAttribute('atom_index','%i'%basis.atomnum[io])
        orb.setAttribute('species',basis.label[io])
        orb.setAttribute('position','%f %f %f'%(basis.xyz[io,0],basis.xyz[io,1],basis.xyz[io,2]))
        orb.setAttribute('n','%i'%basis.N[io])
        orb.setAttribute('l','%i'%basis.L[io])
        orb.setAttribute('m','%i'%basis.M[io])
        xmladd(doc,pdos,'data',myprint(DOS[:,ii]))
    doc.writexml(gzip.GzipFile('Device.PDOS.gz','w'))

def myprint(x): # Do numpy list to string
    str=''
    for ii in range(len(x)):
        str+='%s\n'%x[ii]
    return str
def xmladd(doc,parent,name,values):
    # Who came up with xml ... accountant moroons?
    elem = doc.createElement(name)
    parent.appendChild(elem)
    txt=doc.createTextNode(values)
    elem.appendChild(txt)

    
#####################################################
# Start it
main()
#profile.run('main()')
