#! /usr/bin/env python

from Inelastica import SiestaIO as SIO
import numpy as N
from Inelastica import pyTBT
from optparse import OptionParser, OptionGroup
import os, sys, subprocess
        
usage = "usage: %prog [options] DestinationDirectory"

description = """pyTBT is the Python version of TBtrans originally developed by Mads Brandbyge.
For help use --help!
 """
parser = OptionParser(usage,description=description)

# Determine keywords provided
parser.add_option("-n", "--NumChan", dest="numchan", help="Number of eigenchannels [%default]",
                  type='int', default=10)
parser.add_option("-e","--eta", dest="eta", help="Imaginary part added to all energies (device and leads) [%default eV]",
                  type='float', default=0.000001)
parser.add_option("-l","--etaLead", dest="etaLead", help="Additional imaginary part added ONLY in the leads (surface GF) [%default eV]",
                  type='float', default=0.0)
parser.add_option("-x","--Nk1", dest='Nk1', default=1,type='int',
                  help="k-points Nk1 along a1 [%default]")
parser.add_option("-y","--Nk2", dest='Nk2', default=1,type='int',
                  help="k-points Nk2 along a2 [%default]")
parser.add_option("-a","--Gk1", dest='Gk1', default=0,type='int',
                  help="Gaussian quadrature k-point sampling for a1 direction (2*GK1+1 points) [%default]")
parser.add_option("-b","--Gk2", dest='Gk2', default=0,type='int',
                  help="Gaussian quadrature k-point sampling for a2 direction (2*GK2+1 points) [%default]")
parser.add_option("-s", "--skipsym", dest='skipsymmetry',default=False,action='store_true',
                  help="Skip inversion (time-reversal) symmetry (i.e., k=-k) that reduces the number of k-point evaluations [%default]")
parser.add_option("-f", "--fdf", dest='fn',default='./RUN.fdf',type='string',
                  help="Input fdf-file for TranSIESTA calculations [%default]")
parser.add_option("-d", "--skipDOS", dest='dos',default=True,action='store_false',
                  help="Skip calculation of PDOS [%default]")
parser.add_option("-u", "--useSigNC", dest='signc',default=False,action='store_true',
                  help="Use SigNCfiles [%default]")

(options, args) = parser.parse_args()

# Destination directory
if len(args)!=1:
    parser.error('ERROR: You need to specify a destination directory')
else:
    options.DestDir = args[0]
if not os.path.isdir(options.DestDir):
    print '\npyTBT: Creating folder %s' %options.DestDir
    os.mkdir(options.DestDir)

# Log output to file                                                                                                                                                                                                
sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)
tee = subprocess.Popen(["tee", options.DestDir+"/Output.log"], stdin=subprocess.PIPE)
os.dup2(tee.stdin.fileno(), sys.stdout.fileno())
os.dup2(tee.stdin.fileno(), sys.stderr.fileno())

# Read SIESTA files
options.head,tail = os.path.split(options.fn)
print "pyTBT: Reading keywords from %s \n"%options.fn

options.systemlabel = SIO.GetFDFlineWithDefault(options.fn,'SystemLabel', str, 'Systemlabel', 'Eigenchannels')       
options.TSHS = '%s/%s.TSHS'%(options.head,options.systemlabel)

# Electrodes
options.fnL  = options.head+'/'+SIO.GetFDFlineWithDefault(options.fn,'TS.HSFileLeft', str, None, 'pyTBT')
options.NA1L = SIO.GetFDFlineWithDefault(options.fn,'TS.ReplicateA1Left', int, 1, 'pyTBT')
options.NA2L = SIO.GetFDFlineWithDefault(options.fn,'TS.ReplicateA2Left', int, 1, 'pyTBT')
options.fnR  = options.head+'/'+SIO.GetFDFlineWithDefault(options.fn,'TS.HSFileRight', str, None, 'pyTBT')
options.NA1R = SIO.GetFDFlineWithDefault(options.fn,'TS.ReplicateA1Right', int, 1, 'pyTBT')
options.NA2R = SIO.GetFDFlineWithDefault(options.fn,'TS.ReplicateA2Right', int, 1, 'pyTBT')
options.UseBulk = SIO.GetFDFlineWithDefault(options.fn,'TS.UseBulkInElectrodes', bool, True, 'pyTBT')

# Device region
options.devSt  = SIO.GetFDFlineWithDefault(options.fn,'TS.TBT.PDOSFrom', int, 0, 'pyTBT')
options.devEnd = SIO.GetFDFlineWithDefault(options.fn,'TS.TBT.PDOSTo', int, 0, 'pyTBT')

# Voltage
options.voltage = SIO.GetFDFlineWithDefault(options.fn,'TS.Voltage', float, 0.0, 'pyTBT')

# Energy range
options.nE   = SIO.GetFDFlineWithDefault(options.fn,'TS.TBT.NPoints', int, 21, 'pyTBT')
options.minE = SIO.GetFDFlineWithDefault(options.fn,'TS.TBT.Emin', float, -1.0, 'pyTBT')
options.maxE = SIO.GetFDFlineWithDefault(options.fn,'TS.TBT.Emax', float, 1.0, 'pyTBT')
if options.nE>1:
    options.dE = (options.maxE-options.minE)/float(options.nE-1)
    options.Elist = N.array(range(int((options.maxE-options.minE+1e-9)/options.dE)+1),N.float)*options.dE+options.minE
else:
    options.dE = 0.0
    options.Elist = N.array((options.minE,),N.float)

pyTBT.calc(options)
